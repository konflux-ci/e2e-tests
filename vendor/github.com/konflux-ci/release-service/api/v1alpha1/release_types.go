/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
	"time"

	"github.com/konflux-ci/operator-toolkit/conditions"

	"github.com/konflux-ci/release-service/metadata"
	"github.com/konflux-ci/release-service/metrics"
	"k8s.io/apimachinery/pkg/runtime"

	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// ReleaseSpec defines the desired state of Release.
type ReleaseSpec struct {
	// Snapshot to be released
	// +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
	// +required
	Snapshot string `json:"snapshot"`

	// ReleasePlan to use for this particular Release
	// +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
	// +required
	ReleasePlan string `json:"releasePlan"`

	// Data is an unstructured key used for providing data for the managed Release Pipeline
	// +kubebuilder:pruning:PreserveUnknownFields
	// +optional
	Data *runtime.RawExtension `json:"data,omitempty"`

	// GracePeriodDays is the number of days a Release should be kept
	// This value is used to define the Release ExpirationTime
	// +optional
	GracePeriodDays int `json:"gracePeriodDays,omitempty"`
}

// ReleaseStatus defines the observed state of Release.
type ReleaseStatus struct {
	// Artifacts is an unstructured key used for storing all the artifacts generated by the managed Release Pipeline
	// +kubebuilder:pruning:PreserveUnknownFields
	// +optional
	Artifacts *runtime.RawExtension `json:"artifacts,omitempty"`

	// Attribution contains information about the entity authorizing the release
	// +optional
	Attribution AttributionInfo `json:"attribution,omitempty"`

	// Collectors is an unstructured key used for storing all the collectors results generated by the Collectors Pipeline
	// +kubebuilder:pruning:PreserveUnknownFields
	// +optional
	Collectors *runtime.RawExtension `json:"collectors,omitempty"`

	// Conditions represent the latest available observations for the release
	// +optional
	Conditions []metav1.Condition `json:"conditions"`

	// FinalProcessing contains information about the release final processing
	// +optional
	FinalProcessing PipelineInfo `json:"finalProcessing,omitempty"`

	// ManagedProcessing contains information about the release managed processing
	// +optional
	ManagedProcessing PipelineInfo `json:"managedProcessing,omitempty"`

	// TenantProcessing contains information about the release tenant processing
	// +optional
	TenantProcessing PipelineInfo `json:"tenantProcessing,omitempty"`

	// Validation contains information about the release validation
	// +optional
	Validation ValidationInfo `json:"validation,omitempty"`

	// Target references where this release is intended to be released to
	// +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
	// +optional
	Target string `json:"target,omitempty"`

	// Automated indicates whether the Release was created as part of an automated process or manually by an end-user
	// +optional
	Automated bool `json:"automated,omitempty"`

	// CompletionTime is the time when a Release was completed
	// +optional
	CompletionTime *metav1.Time `json:"completionTime,omitempty"`

	// StartTime is the time when a Release started
	// +optional
	StartTime *metav1.Time `json:"startTime,omitempty"`

	// ExpirationTime is the time when a Release can be purged
	// +optional
	ExpirationTime *metav1.Time `json:"expirationTime,omitempty"`
}

// AttributionInfo defines the observed state of the release attribution.
type AttributionInfo struct {
	// Author is the username that the release is attributed to
	// +optional
	Author string `json:"author,omitempty"`

	// StandingAuthorization indicates whether the release is attributed through a ReleasePlan
	// +optional
	StandingAuthorization bool `json:"standingAuthorization,omitempty"`
}

// PipelineInfo defines the observed state of a release pipeline processing.
type PipelineInfo struct {
	// CompletionTime is the time when the Release processing was completed
	// +optional
	CompletionTime *metav1.Time `json:"completionTime,omitempty"`

	// PipelineRun contains the namespaced name of the managed Release PipelineRun executed as part of this release
	// +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?\/[a-z0-9]([-a-z0-9]*[a-z0-9])?$
	// +optional
	PipelineRun string `json:"pipelineRun,omitempty"`

	// RoleBinding contains the namespaced name of the roleBinding created for the managed Release PipelineRun
	// executed as part of this release
	// +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?\/[a-z0-9]([-a-z0-9]*[a-z0-9])?$
	// +optional
	RoleBinding string `json:"roleBinding,omitempty"`

	// StartTime is the time when the Release processing started
	// +optional
	StartTime *metav1.Time `json:"startTime,omitempty"`
}

// ValidationInfo defines the observed state of the release validation.
type ValidationInfo struct {
	// FailedPostValidation indicates whether the Release was marked as invalid after being initially marked as valid
	FailedPostValidation bool `json:"failedPostValidation,omitempty"`

	// Time is the time when the Release was validated or when the validation state changed
	// +optional
	Time *metav1.Time `json:"time,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=rel
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Snapshot",type=string,JSONPath=`.spec.snapshot`
// +kubebuilder:printcolumn:name="ReleasePlan",type=string,JSONPath=`.spec.releasePlan`
// +kubebuilder:printcolumn:name="Release status",type=string,JSONPath=`.status.conditions[?(@.type=="Released")].reason`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`

// Release is the Schema for the releases API
type Release struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   ReleaseSpec   `json:"spec,omitempty"`
	Status ReleaseStatus `json:"status,omitempty"`
}

// HasFinalPipelineProcessingFinished checks whether the Release Final Pipeline processing has finished, regardless of the result.
func (r *Release) HasFinalPipelineProcessingFinished() bool {
	return r.hasPhaseFinished(finalProcessedConditionType)
}

// HasManagedPipelineProcessingFinished checks whether the Release Managed Pipeline processing has finished, regardless of the result.
func (r *Release) HasManagedPipelineProcessingFinished() bool {
	return r.hasPhaseFinished(managedProcessedConditionType)
}

// HasTenantPipelineProcessingFinished checks whether the Release Tenant Pipeline processing has finished, regardless of the result.
func (r *Release) HasTenantPipelineProcessingFinished() bool {
	return r.hasPhaseFinished(tenantProcessedConditionType)
}

// HasReleaseFinished checks whether the Release has finished, regardless of the result.
func (r *Release) HasReleaseFinished() bool {
	return r.hasPhaseFinished(releasedConditionType)
}

// IsAttributed checks whether the Release was marked as attributed.
func (r *Release) IsAttributed() bool {
	return r.Status.Attribution.Author != ""
}

// IsAutomated checks whether the Release was marked as automated.
func (r *Release) IsAutomated() bool {
	return r.Status.Automated
}

// IsFinalPipelineProcessed checks whether the Release Final Pipeline was successfully processed.
func (r *Release) IsFinalPipelineProcessed() bool {
	return meta.IsStatusConditionTrue(r.Status.Conditions, finalProcessedConditionType.String())
}

// IsManagedPipelineProcessed checks whether the Release Managed Pipeline was successfully processed.
func (r *Release) IsManagedPipelineProcessed() bool {
	return meta.IsStatusConditionTrue(r.Status.Conditions, managedProcessedConditionType.String())
}

// IsTenantPipelineProcessed checks whether the Release Tenant Pipeline was successfully processed.
func (r *Release) IsTenantPipelineProcessed() bool {
	return meta.IsStatusConditionTrue(r.Status.Conditions, tenantProcessedConditionType.String())
}

// IsFinalPipelineProcessing checks whether the Release Final Pipeline processing is in progress.
func (r *Release) IsFinalPipelineProcessing() bool {
	return r.isPhaseProgressing(finalProcessedConditionType)
}

// IsManagedPipelineProcessing checks whether the Release Managed Pipeline processing is in progress.
func (r *Release) IsManagedPipelineProcessing() bool {
	return r.isPhaseProgressing(managedProcessedConditionType)
}

// IsTenantPipelineProcessing checks whether the Release Tenant Pipeline processing is in progress.
func (r *Release) IsTenantPipelineProcessing() bool {
	return r.isPhaseProgressing(tenantProcessedConditionType)
}

// IsReleased checks whether the Release has finished successfully.
func (r *Release) IsReleased() bool {
	return meta.IsStatusConditionTrue(r.Status.Conditions, releasedConditionType.String())
}

// IsReleasing checks whether the Release is in progress.
func (r *Release) IsReleasing() bool {
	return r.isPhaseProgressing(releasedConditionType)
}

// IsValid checks whether the Release validation has finished successfully.
func (r *Release) IsValid() bool {
	return meta.IsStatusConditionTrue(r.Status.Conditions, validatedConditionType.String())
}

// MarkFinalPipelineProcessed marks the Release Final Pipeline as processed.
func (r *Release) MarkFinalPipelineProcessed() {
	if !r.IsFinalPipelineProcessing() || r.HasFinalPipelineProcessingFinished() {
		return
	}

	r.Status.FinalProcessing.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetCondition(&r.Status.Conditions, finalProcessedConditionType, metav1.ConditionTrue, SucceededReason)

	go metrics.RegisterCompletedReleasePipelineProcessing(
		r.Status.FinalProcessing.StartTime,
		r.Status.FinalProcessing.CompletionTime,
		SucceededReason.String(),
		r.Status.Target,
		metadata.FinalPipelineType,
	)
}

// MarkManagedPipelineProcessed marks the Release Managed Pipeline as processed.
func (r *Release) MarkManagedPipelineProcessed() {
	if !r.IsManagedPipelineProcessing() || r.HasManagedPipelineProcessingFinished() {
		return
	}

	r.Status.ManagedProcessing.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetCondition(&r.Status.Conditions, managedProcessedConditionType, metav1.ConditionTrue, SucceededReason)

	go metrics.RegisterCompletedReleasePipelineProcessing(
		r.Status.ManagedProcessing.StartTime,
		r.Status.ManagedProcessing.CompletionTime,
		SucceededReason.String(),
		r.Status.Target,
		metadata.ManagedPipelineType,
	)
}

// MarkTenantPipelineProcessed marks the Release Tenant Pipeline as processed.
func (r *Release) MarkTenantPipelineProcessed() {
	if !r.IsTenantPipelineProcessing() || r.HasTenantPipelineProcessingFinished() {
		return
	}

	r.Status.TenantProcessing.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetCondition(&r.Status.Conditions, tenantProcessedConditionType, metav1.ConditionTrue, SucceededReason)

	go metrics.RegisterCompletedReleasePipelineProcessing(
		r.Status.TenantProcessing.StartTime,
		r.Status.TenantProcessing.CompletionTime,
		SucceededReason.String(),
		r.Status.Target,
		metadata.TenantPipelineType,
	)
}

// MarkFinalPipelineProcessing marks the Release Final Pipeline as processing.
func (r *Release) MarkFinalPipelineProcessing() {
	if r.HasFinalPipelineProcessingFinished() {
		return
	}

	if !r.IsFinalPipelineProcessing() {
		r.Status.FinalProcessing.StartTime = &metav1.Time{Time: time.Now()}
	}

	conditions.SetCondition(&r.Status.Conditions, finalProcessedConditionType, metav1.ConditionFalse, ProgressingReason)

	go metrics.RegisterNewReleasePipelineProcessing(
		r.Status.FinalProcessing.StartTime,
		r.Status.StartTime,
		ProgressingReason.String(),
		r.Status.Target,
		metadata.FinalPipelineType,
	)
}

// MarkManagedPipelineProcessing marks the Release Managed Pipeline as processing.
func (r *Release) MarkManagedPipelineProcessing() {
	if r.HasManagedPipelineProcessingFinished() {
		return
	}

	if !r.IsManagedPipelineProcessing() {
		r.Status.ManagedProcessing.StartTime = &metav1.Time{Time: time.Now()}
	}

	conditions.SetCondition(&r.Status.Conditions, managedProcessedConditionType, metav1.ConditionFalse, ProgressingReason)

	go metrics.RegisterNewReleasePipelineProcessing(
		r.Status.ManagedProcessing.StartTime,
		r.Status.StartTime,
		ProgressingReason.String(),
		r.Status.Target,
		metadata.ManagedPipelineType,
	)
}

// MarkTenantPipelineProcessing marks the Release Tenant Pipeline as processing.
func (r *Release) MarkTenantPipelineProcessing() {
	if r.HasTenantPipelineProcessingFinished() {
		return
	}

	if !r.IsTenantPipelineProcessing() {
		r.Status.TenantProcessing.StartTime = &metav1.Time{Time: time.Now()}
	}

	conditions.SetCondition(&r.Status.Conditions, tenantProcessedConditionType, metav1.ConditionFalse, ProgressingReason)

	go metrics.RegisterNewReleasePipelineProcessing(
		r.Status.TenantProcessing.StartTime,
		r.Status.StartTime,
		ProgressingReason.String(),
		r.Status.Target,
		metadata.TenantPipelineType,
	)
}

// MarkFinalPipelineProcessingFailed marks the Release Final Pipeline processing as failed.
func (r *Release) MarkFinalPipelineProcessingFailed(message string) {
	if !r.IsFinalPipelineProcessing() || r.HasFinalPipelineProcessingFinished() {
		return
	}

	r.Status.FinalProcessing.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetConditionWithMessage(&r.Status.Conditions, finalProcessedConditionType, metav1.ConditionFalse, FailedReason, message)

	go metrics.RegisterCompletedReleasePipelineProcessing(
		r.Status.FinalProcessing.StartTime,
		r.Status.FinalProcessing.CompletionTime,
		FailedReason.String(),
		r.Status.Target,
		metadata.FinalPipelineType,
	)
}

// MarkManagedPipelineProcessingFailed marks the Release Managed Pipeline processing as failed.
func (r *Release) MarkManagedPipelineProcessingFailed(message string) {
	if !r.IsManagedPipelineProcessing() || r.HasManagedPipelineProcessingFinished() {
		return
	}

	r.Status.ManagedProcessing.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetConditionWithMessage(&r.Status.Conditions, managedProcessedConditionType, metav1.ConditionFalse, FailedReason, message)

	go metrics.RegisterCompletedReleasePipelineProcessing(
		r.Status.ManagedProcessing.StartTime,
		r.Status.ManagedProcessing.CompletionTime,
		FailedReason.String(),
		r.Status.Target,
		metadata.ManagedPipelineType,
	)
}

// MarkTenantPipelineProcessingFailed marks the Release Tenant Pipeline processing as failed.
func (r *Release) MarkTenantPipelineProcessingFailed(message string) {
	if !r.IsTenantPipelineProcessing() || r.HasTenantPipelineProcessingFinished() {
		return
	}

	r.Status.TenantProcessing.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetConditionWithMessage(&r.Status.Conditions, tenantProcessedConditionType, metav1.ConditionFalse, FailedReason, message)

	go metrics.RegisterCompletedReleasePipelineProcessing(
		r.Status.TenantProcessing.StartTime,
		r.Status.TenantProcessing.CompletionTime,
		FailedReason.String(),
		r.Status.Target,
		metadata.TenantPipelineType,
	)
}

// MarkFinalPipelineProcessingSkipped marks the Release Final Pipeline processing as skipped.
func (r *Release) MarkFinalPipelineProcessingSkipped() {
	if r.HasFinalPipelineProcessingFinished() {
		return
	}

	conditions.SetCondition(&r.Status.Conditions, finalProcessedConditionType, metav1.ConditionTrue, SkippedReason)
}

// MarkManagedPipelineProcessingSkipped marks the Release Managed Pipeline processing as skipped.
func (r *Release) MarkManagedPipelineProcessingSkipped() {
	if r.HasManagedPipelineProcessingFinished() {
		return
	}

	conditions.SetCondition(&r.Status.Conditions, managedProcessedConditionType, metav1.ConditionTrue, SkippedReason)
}

// MarkTenantPipelineProcessingSkipped marks the Release Tenant Pipeline processing as skipped.
func (r *Release) MarkTenantPipelineProcessingSkipped() {
	if r.HasTenantPipelineProcessingFinished() {
		return
	}

	conditions.SetCondition(&r.Status.Conditions, tenantProcessedConditionType, metav1.ConditionTrue, SkippedReason)
}

// MarkReleased marks the Release as released.
func (r *Release) MarkReleased() {
	if !r.IsReleasing() || r.HasReleaseFinished() {
		return
	}

	r.Status.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetCondition(&r.Status.Conditions, releasedConditionType, metav1.ConditionTrue, SucceededReason)

	go metrics.RegisterCompletedRelease(
		r.Status.StartTime,
		r.Status.CompletionTime,
		r.getPhaseReason(managedProcessedConditionType),
		SucceededReason.String(),
		r.Status.Target,
		r.getPhaseReason(tenantProcessedConditionType),
		r.getPhaseReason(finalProcessedConditionType),
		r.getPhaseReason(validatedConditionType),
	)
}

// MarkReleasing marks the Release as releasing.
func (r *Release) MarkReleasing(message string) {
	if r.HasReleaseFinished() {
		return
	}

	if !r.IsReleasing() {
		r.Status.StartTime = &metav1.Time{Time: time.Now()}
	}

	conditions.SetConditionWithMessage(&r.Status.Conditions, releasedConditionType, metav1.ConditionFalse, ProgressingReason, message)

	go metrics.RegisterNewRelease()
}

// MarkReleaseFailed marks the Release as failed.
func (r *Release) MarkReleaseFailed(message string) {
	if !r.IsReleasing() || r.HasReleaseFinished() {
		return
	}

	r.Status.CompletionTime = &metav1.Time{Time: time.Now()}
	conditions.SetConditionWithMessage(&r.Status.Conditions, releasedConditionType, metav1.ConditionFalse, FailedReason, message)

	go metrics.RegisterCompletedRelease(
		r.Status.StartTime,
		r.Status.CompletionTime,
		r.getPhaseReason(tenantProcessedConditionType),
		r.getPhaseReason(managedProcessedConditionType),
		r.getPhaseReason(finalProcessedConditionType),
		FailedReason.String(),
		r.Status.Target,
		r.getPhaseReason(validatedConditionType),
	)
}

// MarkValidated marks the Release as validated.
func (r *Release) MarkValidated() {
	if r.IsValid() {
		return
	}

	r.Status.Validation.Time = &metav1.Time{Time: time.Now()}
	conditions.SetCondition(&r.Status.Conditions, validatedConditionType, metav1.ConditionTrue, SucceededReason)

	go metrics.RegisterValidatedRelease(
		r.Status.StartTime,
		r.Status.Validation.Time,
		SucceededReason.String(),
		r.Status.Target,
	)
}

// MarkValidationFailed marks the Release validation as failed.
func (r *Release) MarkValidationFailed(message string) {
	if r.IsValid() {
		r.Status.Validation.FailedPostValidation = true
	}

	r.Status.Validation.Time = &metav1.Time{Time: time.Now()}
	conditions.SetConditionWithMessage(&r.Status.Conditions, validatedConditionType, metav1.ConditionFalse, FailedReason, message)

	go metrics.RegisterValidatedRelease(
		r.Status.StartTime,
		r.Status.Validation.Time,
		FailedReason.String(),
		r.Status.Target,
	)
}

// SetAutomated marks the Release as automated.
func (r *Release) SetAutomated() {
	if r.IsAutomated() {
		return
	}

	r.Status.Automated = true
}

// SetExpirationTime set the time when this release can be purged
func (r *Release) SetExpirationTime(expireDays time.Duration) {
	creationTime := r.CreationTimestamp
	r.Status.ExpirationTime = &metav1.Time{Time: creationTime.Add(time.Hour * 24 * expireDays)}
}

// getPhaseReason returns the current reason for the given ConditionType or empty string if no condition is found.
func (r *Release) getPhaseReason(conditionType conditions.ConditionType) string {
	var reason string

	condition := meta.FindStatusCondition(r.Status.Conditions, conditionType.String())
	if condition != nil {
		reason = condition.Reason
	}

	return reason
}

// hasPhaseFinished checks whether a Release phase (e.g. deployment or processing) has finished.
func (r *Release) hasPhaseFinished(conditionType conditions.ConditionType) bool {
	condition := meta.FindStatusCondition(r.Status.Conditions, conditionType.String())

	switch {
	case condition == nil:
		return false
	case condition.Status == metav1.ConditionTrue:
		return true
	default:
		return condition.Status == metav1.ConditionFalse && condition.Reason != ProgressingReason.String()
	}
}

// isPhaseProgressing checks whether a Release phase (e.g. deployment or processing) is progressing.
func (r *Release) isPhaseProgressing(conditionType conditions.ConditionType) bool {
	condition := meta.FindStatusCondition(r.Status.Conditions, conditionType.String())

	switch {
	case condition == nil:
		return false
	case condition.Status == metav1.ConditionTrue:
		return false
	default:
		return condition.Status == metav1.ConditionFalse && condition.Reason == ProgressingReason.String()
	}
}

// +kubebuilder:object:root=true

// ReleaseList contains a list of Release
type ReleaseList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Release `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Release{}, &ReleaseList{})
}
